17. Letter Combinations of a Phone Number
===========================================
void helper(string digits, vector<string> &op, vector<string>& sList, int idx, string tmp)
{
    if(tmp.size() == digits.size())
    {
        op.push_back(tmp);
        return;
    }

    int strpos = digits[idx] - '0';
    string sval = sList[strpos];
    for(int i=0; i<sval.size(); i++)
    {
        helper(digits, op, sList, idx+1, tmp+sval[i]);
    }
}
vector<string> letterCombinations(string digits) 
{
    vector<string> sList = {"","", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
    vector<string> op;
    string str ="";
    helper(digits,op,sList,0,"");
    return op;
}
int main()
{ 
    string digits ="23";
    vector<string> sList = letterCombinations(digits);
    for(int i=0; i<sList.size(); i++)
    {
        cout<<sList[i]<<" ";
    }
}
===============================================================================================================
22. Generate Parentheses
==========================
void helper(vector<string> &op, string tmp, int openCnt, int closeCnt, int n)
{
    if(tmp.size()==2*n)
    {
        op.push_back(tmp);
    }

    if(openCnt < n)
    {
        helper(op, tmp+"(", openCnt+1, closeCnt, n);
    }
    if(closeCnt<openCnt)
    {
        helper(op, tmp+")", openCnt, closeCnt+1, n);
    }
}

vector<string> generateParenthesis(int n)
{
    vector<string> op;
    string tmp = "";
    int openCnt = 0;
    int closeCnt = 0;
    helper(op,tmp,openCnt,closeCnt,n);
    return op;
}

int main(int argc, char* argv[])
{
    int  n=3;
    vector<string> sList = generateParenthesis(n);
    for(int i=0; i<sList.size(); i++)
    {
        cout<<sList[i]<<" ";
    }
}
===============================================================================================================
39. Combination Sum
====================
void helper(vector<vector<int>> &op, vector<int> &tmp, vector<int>& candidates, int target, int sum, int idx)
{
    if(sum>target)
    {
        return;
    }
    if(sum==target)
    {
        op.push_back(tmp);
    }
    else
    {
        for(int i=idx; i<candidates.size();i++)
        {
            tmp.push_back(candidates[i]);
            helper(op,tmp,candidates,target,sum+candidates[i], i);
            tmp.pop_back();
        }
    }
}

vector<vector<int>> combinationSum(vector<int>& candidates, int target) 
{
    vector<vector<int>> op ;
    vector<int> tmp;
    int sum =0;
    helper(op, tmp, candidates, target, sum,0);
    return op;
}

int main()
{
    vector<int> candidates = {2,3,6,7};
    int target = 7;
    vector<vector<int>> op = combinationSum(candidates, target);
    cout<<"[";
    for(int i=0; i<op.size(); i++)
    {
        cout<<"[";
        for(int j=0;j<op[i].size(); j++)
        {
            cout<<op[i][j]<<" ";
        }
        cout<<"] ";
    }
    cout<<"] ";
    return 0;
}
======================================================================================================
46. Permutations
==================
//Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
void helper(vector<vector<int>> &op, vector<int> &tmp, vector<int> &nums, vector<int> &flag)
{
    if(tmp.size() == nums.size())
    {
        op.push_back(tmp);
    }
    else
    {
        for(int i=0; i<nums.size(); i++)
        {
            if(flag[i]) continue;
            
            tmp.push_back(nums[i]);

            flag[i] =1;
            helper(op, tmp, nums, flag);
            flag[i]=0;

            tmp.pop_back();
        }
    } 
}
vector<vector<int>> permute(vector<int>& nums)
{
    vector<vector<int>> op;
    vector<int> tmp;
    vector<int> flag(nums.size(),0);
    helper(op, tmp, nums,flag);
    return op;
}
int main()
{
    vector<int> nums = {1,2,3};
    vector<vector<int>> op = permute(nums);
    cout<<"[";
    for(int i=0; i<op.size(); i++)
    {
        cout<<"[";
        for(int j=0; j<op[i].size(); j++)
        {
            cout<<op[i][j]<<" ";
        }
        cout<<"]";
    }
    cout<<"]";
}
===========================================================================
51. N-Queens
=============
//Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
bool isValid(int r, int c, vector<string> &tmp, vector<int> & fcols, int n)
{
    if(fcols[c])
    {
        return false;
    }
    int c_45 =c;
    int c_135 = c;
    for(int row = r-1; row>=0; row--)
    {
        c_45--;
        c_135++;
        if((c_45>=0 && tmp[row][c_45] =='Q') || (c_135<n && tmp[row][c_135] == 'Q'))
        {
            return false;
        }
    }
    return true;
}

void solve(vector<vector<string>> &op, vector<string> & tmp, vector<int> &fcols, int r, int n)
{
    if(n==r)
    {
        op.push_back(tmp);
        return;
    }

    for(int c=0; c<n; c++)
    {
        if(isValid(r,c,tmp,fcols,n))
        {
            tmp[r][c] = 'Q';
            fcols[c]=1;
            solve(op,tmp,fcols, r+1, n);
            fcols[c] =0;
            tmp[r][c]= '.';
        }
    }
}

vector<vector<string>> solveQueens(int n)
{
    vector<vector<string>> op;
    vector<string> tmp(n, string(n,'.'));
    vector<int> fcols(n,0);
    int row =0;
    solve(op, tmp, fcols, row, n);
    return op;
}

int main()
{
    int n=4;
    vector<vector<string>> op = solveQueens(n);
    cout<<"[";
    for(int i=0; i<op.size(); i++)
    {
        cout<<"[";
        for(int j=0; j<op[i].size(); j++)
        {
            cout<<op[i][j]<<" ";
        }
        cout<<"]";
    }
    cout<<"]";
}
========================================================================================
78. Subsets
============
//[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
void helper(vector<vector<int>> &op, vector<int> &tmp, vector<int> &nums, int idx)
{
    op.push_back(tmp);
    if(idx==nums.size())
    {
        return;
    }
    for(int i=idx; i<nums.size(); i++)
    {
        tmp.push_back(nums[i]);
        helper(op, tmp, nums, i+1);
        tmp.pop_back();
    }
}

vector<vector<int>> subsets(vector<int>& nums) 
{
    vector<vector<int>> op;
    vector<int> tmp;
    helper(op, tmp, nums, 0);
    return op;
}

int main()
{
    vector<int> nums = {1, 2, 3};
    vector<vector<int>> op = subsets(nums);
    cout<<"[";
    for(int i=0; i<op.size(); i++)
    {
        cout<<"[";
        for(int j=0; j<op[i].size(); j++)
        {
            cout<<op[i][j]<<" ";
        }
        cout<<"]";
    }
    cout<<"]";
}
=====================================================================================================
79. Word Search
=====================
bool helper(int i, int j, vector<vector<char>> &board, string word, int idx)
{
    bool exist = false;
    if(idx == word.size())
    {
        return true;
    }
    if(i>=0 && i<board.size() && j>=0 && j<board[0].size())
    {
        if(board[i][j] == word[idx])
        {   
            char tmp = board[i][j];
            board[i][j] = '*';
            exist = helper(i, j+1, board, word, idx+1) 
             || helper(i, j-1, board, word, idx+1)
             || helper(i+1, j, board, word, idx+1) 
             || helper(i-1, j, board, word, idx+1);

            board[i][j] = tmp;

        }
    }
    return exist;
}

bool exist(vector<vector<char>> &board, string word)
{
    for(int i=0; i<board.size(); i++)
    {
        for(int j=0; j<board[i].size(); j++)
        {
            if(board[i][j] == word[0])
            {
                if(helper(i, j, board, word, 0))
                {
                    return true;
                }
            }
        }
    }
    return false;
}

int main()
{
    vector<vector<char>> board = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};
    string word = "SEE";
    cout<< exist(board, word);
    return 0;
}
================================================================================================================
131. Palindrome Partitioning
===============================

//Output: [["a","a","b"],["aa","b"]]
bool isPalindrome(string s, int i, int j)
{
    while (i<j)
    {
        if(s[i]!=s[j])
        {
            return false;
        }
        i++;
        j--;
    }
    return true;
}

void helper(vector<vector<string>> &op, vector<string> &tmp, string s, int idx)
{
    if(idx == s.size())
    {
        op.push_back(tmp);
        return;
    }
    for(int i=idx; i<s.size(); i++)
    {
        int len = i-idx+1;
        string str = s.substr(idx, len);
        if(isPalindrome(str, 0, len-1))
        {
            tmp.push_back(str);
            helper(op, tmp, s, i+1);
            tmp.pop_back();
        }
    }
}

vector<vector<string>> partition(string s) 
{
    vector<vector<string>> op;
    vector<string> tmp;
    helper(op, tmp, s, 0);
    return op;
}

int main()
{
    string s = "aab";
    vector<vector<string>> op = partition(s);
    cout<<"[";
    for(int i=0; i<op.size(); i++)
    {
        cout<<"[";
        for(int j=0; j<op[i].size(); j++)
        {
            cout<<op[i][j]<<" ";
        }
        cout<<"]";
    }
    cout<<"]";
    return 0;
}
=============================================================================================
Binary Search:
==============
double findMedianSortedArrays(vector<int>& numsA, vector<int>& numsB)
{
    int lenA = numsA.size();
    int lenB = numsB.size();
    if(lenB<lenA)
    {
        return findMedianSortedArrays(numsB, numsA);
    }

    int l = 0; 
    int r = lenA-1; //4
    int total = lenA+lenB; //8+5 = 13
    int half = total/2; //6
    //123 45
    //123 4567

    int Aleft, Aright, Bleft, Bright;
    while(l<r)
    {
        int m1 = (l+r)/2;  //0+4/2 = 2
        int m2 = half-m1-2; //6-2-2 = 2
        if(r<0)
        {
            m1 = r;
            m2 = half-1;
        }
        
        if(m1>=0 && m1<lenA)
        {
            Aleft = numsA[m1];
            Aright = numsA[m1+1];
        }
        else
        {
            Aleft = INT_MIN;
            Aright = INT_MAX;
        }
         
        if(m2>=0 && m2<lenB)
        {
            Bleft = numsB[m2];
            Bright = numsB[m2+1];
        }
        else
        {
            Bleft = INT_MIN;
            Bright = INT_MAX;
        }

        if(Aleft<=Bright && Bleft<=Aright)
        {
            if(total%2)
            {
                return min(Aright,Bright);
            }
            else
            {
                return (double)(max(Aleft,Bleft)+min(Aright,Bright))/2;
            }
        }
        else
        {
            if(Aleft>Bright)
            {
                r=m1-1;
            }
            else
            {
                l=m1+1;
            }
        }          
    }
    return 0;
}
int main()
{
    vector<int> nums1 = {1,2,3,4,5,6,7};
    vector<int> nums2 = {2,3,3,5};
    cout<<findMedianSortedArrays(nums1, nums2);
}
=============================================================================================
33. Search in Rotated Sorted Array
===================================
int findMinIndex(vector<int>& nums)
{
    int i=0;
    int j=nums.size()-1; //6
    while(i<j) 
    {
        int m = (i+j)/2; //3, (4+6)/2=5, (4+5)/2=4

        if(nums[m]>= nums[j]) // >=2, 1>=2, 0>=2
        {
            i=m+1;  //4
        }
        else{
            j=m;  //5, 4
        }
    }
    return i;
}
//[4,5,6,7,0,1,2], target = 0
int search(vector<int>& nums, int target)
{
    int minIdx = findMinIndex(nums); //4
    int i=0;
    int j= nums.size()-1; //6
    while(i<=j)
    {
        int mid = (i+j)/2; //3
        int realMid = (mid+minIdx)% nums.size(); //(3+4)%7=0;
        if(nums[realMid]==target)
        {
            return realMid;
        }

        if(nums[realMid]>target)
        {
            j= mid-1;
        }
        else{
            i=mid+1;
        }
    }
    return -1;
}
int main()
{
	vector<int> nums = {4,5,6,7,0,1,2};
	int target =7;
    cout<<search(nums,target);
}
=============================================================================================
34. Find First and Last Position of Element in Sorted Array
============================================================

int findMinIdx(vector<int> &nums, int target)
{
    int i=0;
    int j=nums.size()-1;
    int idx =-1;
    while(i<=j)
    {
        int m = (i+j)/2;
        if(nums[m]>= target)
        {
            j = m-1;
        }
        else
        {
            i = m+1;
        }
        if(nums[m]==target)
        {
            idx = m;
        }
    }
    return idx;
}

int findMaxIdx(vector<int> &nums, int target)
{
    int i=0;
    int j=nums.size()-1;
    int idx=-1;
    while(i<j)
    {
        int m = (i+j)/2;
        if(nums[m]<=target)
        {
            i=m+1;
        }
        else
        {
            j=m-1;
        }
        if(nums[m]== target)
        {
            idx = m;
        }
    }
    return idx;
}

vector<int> searchRange(vector<int>& nums, int target)
{
    int left = findMinIdx(nums, target);
    int right = findMaxIdx(nums, target);
    return {left,right};
}

int main()
{
    vector<int> nums = {5,7,7,8,8,10};
    int target = 7;
    searchRange(nums, target);
}
=================================================================================   
35. Search Insert Position
===========================
int searchInsert(vector<int>& nums, int target)
{
    int i=0; 
    int j=nums.size()-1;
    while(i<=j)
    {
        int m=(i+j)/2;
        if(nums[m]==target)
        {
            return m;
        }

        if(nums[m]>target)
        {
            j=m-1;
        }
        else
        {
            i=m+1;
        }
    }
    return i;
}

int main()
{
    vector<int> nums = {1,3,5,6};
    int target = 2;
    cout<<searchInsert(nums,target);
    return 0;

}
==================================================================================
74. Search a 2D Matrix
=======================
bool searchMatrix(vector<vector<int>>& nums, int target)
{
    int i=0;
    int j=nums.size()-1;
    int cj= nums[0].size()-1;
    while(i<j)
    {
        int m=(i+j)/2;
        if(nums[m][cj] < target)
        {
            i=m+1;
        }
        else if(nums[m][0]>target)
        {
            j=m-1;
        }
        else{
            break;
        }
    }

    int row = i;

    i=0;
    j=cj;
    while(i<j)
    {
        int m=(i+j)/2;
        if(nums[row][m] == target)
        {
           return true;
        }
        if(nums[row][m] > target)
        {
            j=m-1;
        } 
        else
        {
            i=m+1;
        }
    }
    return false;
}

int main()
{
    vector<vector<int>> matrix = {{1,33,5,7},{10,11,16,20},{23,30,34,60}};
    int target = 3;
    cout<<searchMatrix(matrix,target);
    return 0;
}
============================================================================================
124. Binary Tree Maximum Path Sum
==================================
int pathsum(TreeNode* node, int& maxsum)
{
    if(node == nullptr)
    {
        return 0;
    }

    int left = max(pathsum(node->left,maxsum),0);
    int right = max(pathsum(node->right, maxsum),0);
    maxsum = max(maxsum, node->val+left+right);
    return (max(left,right)+node->val);
}
int maxPathSum(TreeNode* root) 
{
    int maxsum = INT_MIN;
    return max(pathsum(root, maxsum), maxsum);
}
===========================================================================================
153. Find Minimum in Rotated Sorted Array
==========================================
int findMin(vector<int>& nums) 
{
       int i=0;
       int j=nums.size()-1;
       while(i<j)
       {
           int m= (i+j)/2;

           if(nums[m] > nums[j])
           {
               i = m+1;
           }
           else
           {
               j = m;
           }
       }
       return nums[i];
}
==============================================================================================
94. Binary Tree Inorder Traversal
====================================
vector<int> inorderTraversal(TreeNode* root) 
{
    vector<int> ans;
    stack<TreeNode*> stk;
    TreeNode* curr = root;
    while(curr|| !stk.empty())
    {
        while(curr!=nullptr)
        {
            stk.push(curr);
            curr = curr->left;
        }
        curr = stk.top();
        ans.push_back(curr->val);
        stk.pop();
        curr = curr->right;
    }
    return ans;
}
==============================================================
98. Validate Binary Search Tree
================================
bool isvalid(TreeNode* node, long left, long right)
{
    if(node == nullptr)
    {
        return true;
    }
    
    if(node->val > left && node->val< right)
    {
        return isvalid(node->left, left, node->val) && isvalid(node->right, node->val, right);
    }
    return false;
}
bool isValidBST(TreeNode* root) 
{   
    return isvalid(root, LONG_MIN, LONG_MAX);
}
=====================================================================================================
101. Symmetric Tree
========================
bool isSymmetric(TreeNode* root) 
{
    if(!root)
        return true;

    stack<TreeNode*> s;
    if(root->left)
    {
        s.push(root->left);
    }
    if(root->right)
    {
        s.push(root->right);
    }
    TreeNode* left;
    TreeNode* right;
    while(!s.empty())
    {
        if(s.size()%2!=0)
            return false;

        right= s.top(); s.pop();
        left = s.top(); s.pop();
        if(right->val != left->val) return false;

        if(left->left)
        {
            if(!right->right) return false;
            s.push(left->left);
            s.push(right->right);
        }
        else
        {
            if(right->right) return false;
        }

        if(left->right)
        {
            if(!right->left) return false;
            s.push(left->right);
            s.push(right->left);
        }
        else
        {
            if(right->left) return false;
        }
    }
    return true;  
}
====================================================================================
102. Binary Tree Level Order Traversal
=========================================
vector<vector<int>> levelOrder(TreeNode* root) 
{
    vector<vector<int>> ans;
    if(!root)
        return ans;

    queue<TreeNode*> q;
    q.push(root);
    vector<int> tmp;
    while(!q.empty())
    {
        int s= q.size();
        
        for(int i=0; i<s; i++)
        {
            TreeNode* node  = q.front();
            tmp.push_back(node->val);
            q.pop();
            if(node->left)
                q.push(node->left);
            if(node->right)
                q.push(node->right);
        }
        ans.push_back(tmp);
        tmp.clear();
    }
    return ans;
}
=================================================================================================================
105. Construct Binary Tree from Preorder and Inorder Traversal
================================================================
TreeNode* helper(int preIdx, int inStart, int inEnd, vector<int>& preorder, vector<int>& inorder)
{
    if(preIdx >=preorder.size() || inStart > inEnd)
    {
        return nullptr;
    }

    TreeNode* node = new TreeNode(preorder[preIdx]);
    int inIndex = -1;
    for(int i =0; i<inorder.size(); i++)
    {
        if(preorder[preIdx] == inorder[i])
        {
            inIndex=i;
            break;
        }
    } 
    node->left = helper(preIdx+1, inStart, inIndex-1, preorder, inorder);

    int numsOnLeft = inIndex - inStart;
    int rightNodePos = preIdx+ numsOnLeft+ 1;
    node->right = helper(rightNodePos, inIndex+1, inEnd,preorder, inorder );
    return node;
}
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) 
{
    return  helper(0,0,inorder.size()-1,preorder, inorder);
}
=================================================================================================================
108. Convert Sorted Array to Binary Search Tree
==================================================
TreeNode* helper(vector<int>& nums, int start , int end)
{
    if(start>end)
    {
        return nullptr;
    }
    int mid = (start+end)/2;
    TreeNode *root = new TreeNode(nums[mid]);
    root->left = helper(nums, start, mid-1);
    root->right = helper(nums, mid+1, end);
    return root;
}
TreeNode* sortedArrayToBST(vector<int>& nums) 
{
    return helper(nums, 0, nums.size()-1);
}	
=================================================================================================================
114. Flatten Binary Tree to Linked List
=========================================
TreeNode* prev = nullptr;
void flatten(TreeNode* root) 
{
    if(!root)
       return;
    
    flatten(root->right);
    flatten(root->left);
    root->right = prev ;
    root->left = nullptr;
    prev = root; 
}
=================================================================================================================
199. Binary Tree Right Side View
=================================
void helper(TreeNode* root, vector<int>& ans, int depth)
{
    if(!root)
        return;

    if(depth== ans.size())
        ans.push_back(root->val);
    
    helper(root->right, ans, depth+1);
    helper(root->left, ans, depth+1);
}
vector<int> rightSideView(TreeNode* root) 
{
    vector<int> ans;
    helper(root, ans, 0);
    return ans;
}
==========================================================================================
226. Invert Binary Tree
========================
TreeNode* invertTree(TreeNode* root) 
{
    if(!root)
    {
        return nullptr;
    }

    TreeNode* tmp =  invertTree(root->left);
    root->left =  invertTree(root->right);
    root->right = tmp;
    return root;
}
==========================================================================================
230. Kth Smallest Element in a BST
====================================
int kthSmallest(TreeNode* root, int k) 
{   
    if(root)
    {
        stack<TreeNode*> s;
        TreeNode* curr = root;
        int popCnt = 0;
        while(curr || !s.empty())
        {
            while(curr)
            {
                s.push(curr);
                curr= curr->left;
            }
            if(!s.empty())
            {
                curr = s.top(); s.pop();
                popCnt++;
                if(popCnt == k)
                {
                    return curr->val;
                }
            }
            curr = curr->right;
        }
    }
    return 0;   
}
=============================================================================================
236. Lowest Common Ancestor of a Binary Tree
=============================================
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 
{
    unordered_map<TreeNode*,TreeNode*> map;
    queue<TreeNode*> qu;
    qu.push(root);
    while(!qu.empty())
    {
        TreeNode* parent = qu.front();
        qu.pop();
        if(parent->left)
        {
            map[parent->left] = parent;
            qu.push(parent->left);
        }
        if(parent->right)
        {
            map[parent->right] = parent;
            qu.push(parent->right);
        }
    }

    unordered_set<TreeNode*> set;
    while(p)
    {
        set.insert(p);
        p = map[p];   
    }
    while(!set.count(q))
    {
        q = map[q];
    }
    return q;
}
=============================================================================================	
437. Path Sum III
===================
int helper(TreeNode* root, int targetSum, long newSum, unordered_map<long,int>&mp)
{
    int cnt=0;
    if(!root)
    {
        return 0;
    }
    newSum += root->val;
    cnt = mp[newSum-targetSum];

    mp[newSum]++;

    int left = helper(root->left, targetSum, newSum, mp);
    int right = helper(root->right, targetSum, newSum, mp);
    
    mp[newSum]--;
    return left+right+cnt;
}
int pathSum(TreeNode* root, int targetSum) 
{
    if(!root)
        return 0;
    unordered_map<long, int> mp;
    mp[0] = 1;
    return helper(root, targetSum, 0, mp);
}
=============================================================================================